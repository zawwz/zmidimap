
Maps midi signals coming from ALSA midi devices to shell commands
For a release build: `$ make clean ; make -B RELEASE=true`

usage: midiMap <config file>
This is a daemon program, it does not start any background process by itself and needs to be constantly running for the mapping to be active

This program is in early stage but is fully functional without any major errors

TODO:
- Use integrated C MIDI control
- Support for multiple identical devices
- Support for system reserved commands
- Options
- Better error handling on wrong config file format


See 'example.mim' for an example config file


-- COMMAND FORMAT --

Format is a regular shell format

-- Environment
- Global
$channel: channel of the
$id: id of the note/controller

- Note
$velocity: velocity of the note

- Controller
$value: value of the controller (remapped)
$rawvalue: original value of the controller


-- FILE FORMAT --
[<device>,<device>]

- <device> format:
{
name=<name>
commands=[<command>,<command>]
}
-
*name: string referring to client name of the device ($ aseqdump -l)

- command format (global):
{
type=<note/controller>
id=<x>
shell=<shell command>
channel=<*/x>
}
-
*id: value from 0 to 127 referring to id of note/controller
  > mandatory
*shell: shell command to be executed
  > mandatory
*channel: value from 0 to 16 for channel. Can use * for any channel
  > optional, default *


- <command> format (note)
{
trigger=<x:y/x>
}
-
*trigger: note velocity from 0 to 127 that triggers the command. Can enter an interval x:y or single value
  > optional, default 1:127

- <command> format (note)
{
range=<x:y>
remap=<x:y>
float=<true/false>
}
-
*range: controller value from 0 to 127 that triggers command. Can enter an interval x:y or single value
  > optional, default 0:127
*remap: remaps the range to given interval. Interval can be inversed and float
  > optional, default same as range
*float: boolean value defining if output is a floating point value
  > optional, default false

- Comments can be written inside {} by doing //=<COMMENT>
